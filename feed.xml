<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://soonj817.github.io/</id><title>SoonJ</title><subtitle>성공한 삶보단 행복한 삶을 살고 싶은 개발자의 블로그입니다.</subtitle> <updated>2021-09-30T14:16:37+09:00</updated> <author> <name>Soon Jae Jung</name> <uri>https://soonj817.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://soonj817.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko-KR" href="https://soonj817.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2021 Soon Jae Jung </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>지킬 포스트를 한글.md로 만들면 404가 뜬다.</title><link href="https://soonj817.github.io/posts/new-start/" rel="alternate" type="text/html" title="지킬 포스트를 한글.md로 만들면 404가 뜬다." /><published>2021-09-30T00:00:00+09:00</published> <updated>2021-09-30T00:00:00+09:00</updated> <id>https://soonj817.github.io/posts/new-start/</id> <content src="https://soonj817.github.io/posts/new-start/" /> <author> <name>Soon Jae Jung</name> </author> <category term="diary" /> <summary> 블로그 다시 시작합니다. New Start!!! 덧) 올해 목표 하나 달성…! 이직에 성공했습니다 :) </summary> </entry> <entry><title>함수형 프로그래밍 no.01</title><link href="https://soonj817.github.io/posts/must-know-to-make-application/" rel="alternate" type="text/html" title="함수형 프로그래밍 no.01" /><published>2021-04-26T00:00:00+09:00</published> <updated>2021-04-26T00:00:00+09:00</updated> <id>https://soonj817.github.io/posts/must-know-to-make-application/</id> <content src="https://soonj817.github.io/posts/must-know-to-make-application/" /> <author> <name>Soon Jae Jung</name> </author> <category term="programming" /> <category term="functional-programming" /> <summary> 어플리케이션의 설계 요소 확장성: 추가 기능을 지원하기 위해 계속 코드를 리팩토링해야 하는가? 모듈화 용이성: 파일 하나를 고치면 다른 파일도 영향을 받는가? 재사용성: 중복이 많은가? 테스트성: 함수를 단위 테스트하기 어려운가? 헤아리기 쉬움: 체계도 없고 따라가기 어려운 코드인가? 위 목록 중 한가지라도 ‘예’ 또는 ‘잘 모르겠습니다.’ 라는 대답이 나온다면 함수형 프로그래밍(FP)를 공부해보시길… 함수형 프로그래밍의 기본 개념 선언적 프로그래밍 순수 함수 참조 투명성 불변성 </summary> </entry> <entry><title>Subject vs EventEmitter</title><link href="https://soonj817.github.io/posts/subject-vs-eventemitter/" rel="alternate" type="text/html" title="Subject vs EventEmitter" /><published>2021-04-19T00:00:00+09:00</published> <updated>2021-04-19T00:00:00+09:00</updated> <id>https://soonj817.github.io/posts/subject-vs-eventemitter/</id> <content src="https://soonj817.github.io/posts/subject-vs-eventemitter/" /> <author> <name>Soon Jae Jung</name> </author> <category term="framework" /> <category term="angular" /> <summary> 지난 포스트에서 언급했다시피 얼마전 서로 다른 컴포넌트에서 상태를 전달하기 위해 코드 작성 중 의문이 생겼다. Angular에서 컴포넌트간 데이터를 전달할 때 3가지 방식이 있다. EventEmitter service 패턴 RxJS 이번 포스트는 위 세가지 방법의 차이점에 대해 소개해볼 생각이다. EventEmitter EventEmitter는 아래와 같이 선언하고, @Output() postData = new EventEmitter() 아래와 같이 listen한다. @Input() listPost = []; 위 방식은 부모-자식 관계의 component들이 서로간의 데이터를 전달할 때 Angular에서 소개하는 방식이다. 타입 지정이 자유롭고 간편하게 사용할... </summary> </entry> <entry><title>Angular에서 unsubscribe를 사용하는 방법</title><link href="https://soonj817.github.io/posts/the-best-way-to-unsubscribe-in-angular/" rel="alternate" type="text/html" title="Angular에서 unsubscribe를 사용하는 방법" /><published>2021-04-14T00:00:00+09:00</published> <updated>2021-04-15T16:22:21+09:00</updated> <id>https://soonj817.github.io/posts/the-best-way-to-unsubscribe-in-angular/</id> <content src="https://soonj817.github.io/posts/the-best-way-to-unsubscribe-in-angular/" /> <author> <name>Soon Jae Jung</name> </author> <category term="framework" /> <category term="angular" /> <summary> 개요 ※ 이 포스트는 를 번역 및 가공하여 작성하였습니다. 얼마전 서로 다른 컴포넌트에서 상태를 전달하기 위해 subscribe를 사용할 일이 있었다. 일반적으로 subscribe는 component의 생명주기가 다하는 순간 unsubscribe되면서 파괴되지만 종종 그렇지 않을 경우도 있다. 이땐 수동으로 unsubscribe를 해줘야 한다. 그렇지 않으면 불필요한 리소스를 소모하여 앱 성능을 저하시키고, 메모리 누수가 발생할 수 있다. 메모리 누수 예제 @Component({...}) export class AppComponent implements OnInit { subscription: Subscription ngOnInit () { var observabl... </summary> </entry> <entry><title>스코프, 블럭 레벨/함수 레벨 스코프, lexical/동적 스코프, 스코프체인, 클로저</title><link href="https://soonj817.github.io/posts/javascript-scope/" rel="alternate" type="text/html" title="스코프, 블럭 레벨/함수 레벨 스코프, lexical/동적 스코프, 스코프체인, 클로저" /><published>2021-04-13T00:00:00+09:00</published> <updated>2021-04-13T00:00:00+09:00</updated> <id>https://soonj817.github.io/posts/javascript-scope/</id> <content src="https://soonj817.github.io/posts/javascript-scope/" /> <author> <name>Soon Jae Jung</name> </author> <category term="languages" /> <category term="javascript" /> <summary> 스코프 식별자(변수)의 유효범위 자바스크립트 변수에 대한 접근 권한을 정의하는 것이다. global 영역과 local 영역으로 나뉜다. global: 코드 어디에서든지 참조 가능 local: 함수 코드 블록이 만든 스코프, 함수 자신과 하위 함수에서만 참조 가능 var로 변수를 선언할 경우, hoisting이 발생하며, 이는 식별자에 영향을 줄 수 있다. 블럭 레벨 스코프 vs 함수 레벨 스코프 function foo (a) { if(a) { // let b = 'let'; var c = 'var'; } // console.log(b); console.log(c); } foo(true); C언어는 블록 ... </summary> </entry> </feed>
